<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <title>Leaflet-WebView2 test</title>
    <meta name="viewport"
          content="width=device-width, initial-scale=1, shrink-to-fit=no" />

    <link rel="stylesheet" href="main.css" />
    <!-- Leaflet stuff -->

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.8.0/dist/leaflet.css" integrity="sha512-hoalWLoI8r4UszCkZ5kL8vayOGVae1oxXe/2A4AO6J9+580uKHDO3JdHb7NzwwzK5xr/Fs0W40kiNHxM9vyTtQ==" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.8.0/dist/leaflet.js" integrity="sha512-BB3hKbKWOc9Ez/TAwyWxNXeoV9c1v6FIeYiBieIWkpLjauysF18NzgR1MBNBXf8/KABdlkX68nAhlwcDFLGPCQ==" crossorigin=""></script>
    <script src="https://unpkg.com/esri-leaflet@2.2.3/dist/esri-leaflet.js"
            integrity="sha512-YZ6b5bXRVwipfqul5krehD9qlbJzc6KOGXYsDjU9HHXW2gK57xmWl2gU6nAegiErAqFXhygKIsWPKbjLPXVb2g=="
            crossorigin=""></script>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <!--<script src="gaugeGeoData.js"></script>-->

    <style> 

    .leaflet-tooltip { padding: 2px; }
        #map_container {
            background: white;
        }

    </style>

</head>

<body>
    <div id="search_bar">
        <!--Button to search for COMID or GaugeID before actually pulling data-->
            <input id="searchBox" type="text" placeholder="COMID" style="width: 70px">
            <button id="searchButton" type="submit" onclick="comidClick()">COMID Search</button>

            <!--
            <input id="gaugeBox" type="text" placeholder="Gauge" style="width: 70px">
            <button id="gaugeButton" type="submit" onclick="gaugeClick()">Gauge Search</button>
            -->
        
            <input id="latBox" type="text" placeholder="Latitude" style="width: 70px">
            <input id="lonBox" type="text" placeholder="Longitude" style="width: 70px">
            <button id="coordsButton" type="submit" onclick="coordsClick()">Coords Search</button>
    </div>
    <div id="map_container">
        <div id="map"></div>
    </div>
    <p class="hidden" id="comid" value=""></p>
    <p class="hidden" id="lat" value=""></p>
    <p class="hidden" id="lon" value=""></p>
    <script src="./gage_geo.js"></script>
    <script src="./gage_shape.js"></script>
    <script src="./newergeo.js"></script>
    <script src="./markers/Autolinker.min.js"></script>
    <link rel="stylesheet" href="markers\MarkerCluster.css"></script>
    <link rel="stylesheet" href="markers\MarkerCluster.Default.css"></script>
    <script src="markers\leaflet.markercluster-src.js"></script>
    <script src="markers\MarkerCluster.js"></script>
    <script>
        var allShapes = null;
        var geoLayer;
        let SELECTED_LAYER = null;

        const DEFAULT_LAT = document.getElementById("lat").value;
        const DEFAULT_LNG = document.getElementById("lat").value;
        const DEFAULT_ZOOM = 13;
        // NWS Waterbodies
        const URL_NWS_WB =
            "https://mapservices.weather.noaa.gov/static/rest/services/nws_reference_maps/NWM_Lakes_and_Reservoirs/MapServer/0";
        // catchments
        const URL_NP21_CATCHMENTS =
            "https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/Catchments_NP21_Simplified/MapServer/0";
        // WBD - HUC_8
        const URL_NP21_HUC8 =
            "https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/WBD_NP21_Simplified/MapServer/2";
        // flowlines
        const URL_NP21_FLOWLINES =
            "https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/NHDSnapshot_NP21/MapServer/0";

        const GEO_TILE_SET = 
            "https://studio.mapbox.com/tilesets/boycejr.d85fvy9x";

        // build base map layer
        var MAP = L.map("map").fitBounds([
            [49.5, -125.02],
            [23.73, -69.05]
        ]);
        MAP.setView([33.882446, -83.654709], 12);

        var markers = L.layerGroup();

        const CenterBox = L.Control.extend({
            options: {
                position: 'bottomright'
            },
            onAdd: function (MAP) {
                return L.DomUtil.create('div', 'center-box');
            },
            setContent: function (content) {
                this.getContainer().innerHTML = 'Map Center: ' + content;
            }
        });

        var centerBox = new CenterBox().addTo(MAP);

        function LatLngToArrayString(ll) {
            return "[" + ll.lat.toFixed(5) + ", " + ll.lng.toFixed(5) + "]";
        }

        MAP.on("layeradd", function (event) {
            if (geoLayer != null) { geoLayer.bringToFront(); }
        });

        MAP.on('moveend', function () {
            centerBox.setContent(LatLngToArrayString(MAP.getCenter()));
        });

        //Creates different map background types for user preference
        const LIGHT_GRAY = L.tileLayer("https://server.arcgisonline.com/arcgis/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}", {
            attribution:
                'Sources: Esri, HERE, Garmin, (c) OpenStreetMap contributors, and the GIS user community',
        });
        const NAT_GEO = L.tileLayer(
            "https://server.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}",
            {
                attribution:
                    "Tiles &copy; Esri &mdash; National Geographic, Esri, DeLorme, NAVTEQ, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, iPC",
            }
        );
        const SATELLITE = L.tileLayer(
            "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
            {
                attribution:
                    "Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community",
            }
        );
        const STREETVIEW = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
        }).addTo(MAP);

        //Adds map backgrounds
        const Base_Maps = {
            "No Map": L.tileLayer(''),
            "Streetview": STREETVIEW,
            "Light Gray": LIGHT_GRAY,
            "ESRI Natl. Geo.": NAT_GEO,
            "ESRI Imagery": SATELLITE,
        };

        //Creates a waterbodies layer for the map
        const WB_LAYER = L.esri
            .featureLayer({
                url: URL_NWS_WB,
                onEachFeature: WBonEachFeature
            }
            );

        //Sets the catchment layer for the map
        const CATCHMENTS_LAYER = L.esri
            .featureLayer({
                url: URL_NP21_CATCHMENTS,
                onEachFeature: CatchonEachFeature
            });
        CATCHMENTS_LAYER.setStyle({
            color: "orange",
            fillOpacity: 0,
            weight: 1,
        });//.addTo(MAP);

        //Creates an autolinker and new document elements to create panes of metadata for each gauge id within geoUSData
        var autolinker = new Autolinker({truncate: {length: 30, location: 'smart'}});
        
        function removeEmptyRowsFromPopupContent(content, feature) {
         var tempDiv = document.createElement('div');
         tempDiv.innerHTML = content;
         var rows = tempDiv.querySelectorAll('tr');
         for (var i = 0; i < rows.length; i++) {
             var td = rows[i].querySelector('td.visible-with-data');
             var key = td ? td.id : '';
             if (td && td.classList.contains('visible-with-data') && feature.properties[key] == null) {
                 rows[i].parentNode.removeChild(rows[i]);
             }
         }
         return tempDiv.innerHTML;
        }
        document.querySelector(".leaflet-popup-pane").addEventListener("load", function(event) {
          var tagName = event.target.tagName,
            popup = MAP._popup;
          // Also check if flag is already set.
          if (tagName === "IMG" && popup && !popup._updated) {
            popup._updated = true; // Set flag to prevent looping.
            popup.update();
          }
        }, true);

        var bounds_group = new L.featureGroup([]);

        //Contains the metadata information the user will see within a pane when they click on a gauge icon
        function pop_NHDPlusV21_US_gage_0(feature, layer) {
            /* Optional metadata that is perhaps not as important to user. Disabled for now
                    <tr>\
                        <td colspan="2">' + (feature.properties['REACHCODE'] !== null ? autolinker.link("REACHCODE: " + feature.properties['REACHCODE'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['REACHRESOL'] !== null ? autolinker.link("REACHRESOL: " + feature.properties['REACHRESOL'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['Measure'] !== null ? autolinker.link("Measure: " + feature.properties['Measure'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['STATE_CD'] !== null ? autolinker.link("STATE_CD: " + feature.properties['STATE_CD'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['STATE'] !== null ? autolinker.link("STATE: " + feature.properties['STATE'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['ActiveDate'] !== null ? autolinker.link("ActiveDate: " + (dateUNIXConvert(feature.properties['ActiveDate'].toLocaleString()))) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['GagesII'] !== null ? autolinker.link("GagesII: " + feature.properties['GagesII'].toLocaleString()) : '') + '</td>\
                    </tr>\
            */
            var popupContent = '<table>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['SOURCE_FEA'] !== null ? autolinker.link("SOURCE_FEA: " + feature.properties['SOURCE_FEA'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['Active'] !== null ? autolinker.link("Active: " + (parseInt(feature.properties['Active'].toLocaleString()) == 1 ? "True" : "False")) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['OBJECTID'] !== null ? autolinker.link("OBJECTID: " + feature.properties['OBJECTID'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['SOURCE_ORI'] !== null ? autolinker.link("SOURCE_ORI: " + feature.properties['SOURCE_ORI'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['FEATUREDET'] !== null ? autolinker.link("FEATUREDET: " + feature.properties['FEATUREDET'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['EventType'] !== null ? autolinker.link("EventType: " + feature.properties['EventType'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['FLComID'] !== null ? autolinker.link("FLComID: " + feature.properties['FLComID'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['AGENCY_CD'] !== null ? autolinker.link("AGENCY_CD: " + feature.properties['AGENCY_CD'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['STATION_NM'] !== null ? autolinker.link("STATION_NM: " + feature.properties['STATION_NM'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['DASqMi'] !== null ? autolinker.link("DASqMi: " + feature.properties['DASqMi'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['DASqKm'] !== null ? autolinker.link("DASqKm: " + feature.properties['DASqKm'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['LatSite'] !== null ? autolinker.link("LatSite: " + feature.properties['LatSite'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['LonSite'] !== null ? autolinker.link("LonSite: " + feature.properties['LonSite'].toLocaleString()) : '') + '</td>\
                    </tr>\
                </table>';
            layer.bindPopup(popupContent, {maxHeight: 400});
            var popup = layer.getPopup();
            var content = popup.getContent();
            var updatedContent = removeEmptyRowsFromPopupContent(content, feature);
            popup.setContent(updatedContent);

            layer.on('click', function (e) {
                try{
                    if (feature.properties['SOURCE_FEA'] != null) sendMessageToDotnet("gauge|" + feature.properties['SOURCE_FEA']);
                }
                catch{

                }
                //sendMessageToDotnet(layer.feature.properties.toString());

                //ChangeFeatureColor(feature, layer);
                // makeSelectedLayer(layer.feature.properties.FEATUREID);
                // let docComId = document.getElementById("comid");
                // docComId.setAttribute("value", layer.feature.properties.FEATUREID.toString());
            });
        }

        //Converts a unix timestamp into a datetime object
        function dateUNIXConvert(unixTime){
            var timeInt = parseInt(unixTime);
            let dateObj = new Date(timeInt * 1000);
            let utcString = dateObj.toUTCString();
            return utcString;
        }

        //green icon
        function activeGauge() {
            return {
                pane: 'pane_NHDPlusV21_US_gage_0',
                radius: 4.0,
                opacity: 1,
                color: 'rgba(35,35,35,1.0)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1,
                fill: true,
                fillOpacity: 1,
                fillColor: 'rgba(6,193,0,1.0)',
                //purple: fillColor: 'rgba(179,18,219,1.0)',
                //orange: fillColor: 'rgba(231,113,72,1.0)',
                interactive: true,
            }
        }

        //red icon
        function inactiveGauge() {
            return {
                pane: 'pane_NHDPlusV21_US_gage_0',
                radius: 4.0,
                opacity: 1,
                color: 'rgba(35,35,35,1.0)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1,
                fill: true,
                fillOpacity: 1,
                fillColor: 'rgba(210,11,11,1.0)',
                interactive: true,
            }
        }

        //creates panes to contain metadata for all markers within geoUSData
        MAP.createPane('pane_NHDPlusV21_US_gage_0');
        MAP.getPane('pane_NHDPlusV21_US_gage_0').style.zIndex = 400;
        MAP.getPane('pane_NHDPlusV21_US_gage_0').style['mix-blend-mode'] = 'normal';
        var GAUGE_LAYER = new L.geoJson(geoUSData, {
            attribution: '',
            interactive: true,
            dataVar: 'geoUSData',
            layerName: 'GAUGE_LAYER',
            pane: 'pane_NHDPlusV21_US_gage_0',
            onEachFeature: pop_NHDPlusV21_US_gage_0,
            pointToLayer: function (feature, latlng) {
                var context = {
                    feature: feature,
                    variables: {}
                };
                if(parseInt(feature.properties['Active']) == 1){
                    return L.circleMarker(latlng, activeGauge(feature));
                }
                else{
                    return L.circleMarker(latlng, inactiveGauge(feature));
                }
                
            },
        });
        var markersBar = L.markerClusterGroup();
        markersBar.addLayer(GAUGE_LAYER);
        markersBar.addTo(MAP);

        //Function that applies to every catchment with the layer. Used to set specific propeties to catchments only
        function CatchonEachFeature(feature, layer) {
            layer.on('click', function (e) {
                try{
                    if (layer.feature.properties.FEATUREID != null) sendMessageToDotnet("comid|" + layer.feature.properties.FEATUREID.toString());
                }
                catch{

                }

                makeSelectedLayer(layer.feature.properties.FEATUREID);
                let docComId = document.getElementById("comid");
                docComId.setAttribute("value", layer.feature.properties.FEATUREID.toString());
            });

            if (layer.feature.properties.FEATUREID != null){
                var str = layer.feature.properties.FEATUREID.toString();
                layer.bindTooltip(str, { opacity: 1.0 });
            }

            
        };

        //Function that applies to every waterbodies with the layer. Used to set specific propeties to certain waterbodies only
        function WBonEachFeature(feature, layer) {
            if (layer.feature.properties.GNIS_NAME != null) {
                var str = layer.feature.properties.GNIS_NAME.toString();
                if (str != ' ') { layer.bindTooltip(str, { permanent: false, opacity: 1.0 }); };
            };
        };

        //Function that applies to every flowlines with the layer. Used to set specific propeties to flowlines only
        function FLonEachFeature(feature, layer) {
            if ((feature.properties.FCODE == 56600) || (feature.properties.FLOWDIR == 0)) {
                layer.setStyle({ opacity: 0.0 });
                return;
            };

            if (layer.feature.properties.COMID != null) {
                var str = '';
                if (layer.feature.properties.GNIS_NAME != null) str = ", " + layer.feature.properties.GNIS_NAME.toString();
                if (str == ' ') str = '';
                str = layer.feature.properties.COMID.toString() + str;
                layer.bindTooltip(str, { opacity: 1.0 });
            };

            layer.on('click', function (e) {
                if (layer.feature.properties.COMID != null) sendMessageToDotnet(layer.feature.properties.COMID.toString());
                //sendMessageToDotnet(layer.feature.properties.toString());

                //ChangeFeatureColor(feature, layer);
                makeSelectedLayer(layer.feature.properties.COMID);
                let docComId = document.getElementById("comid");
                docComId.setAttribute("value", layer.feature.properties.COMID.toString());
            });
        };

        //Sets the boundaries layer for the map
        const BOUNDARIES_LAYER = L.esri
            .featureLayer({
                url: URL_NP21_HUC8,
            });
        BOUNDARIES_LAYER.setStyle({
            color: "red",
            fillOpacity: 0,
            weight: 1,
        });

        //Sets the flowlines layer for the map
        const FLOWLINES_LAYER = L.esri
            .featureLayer({
                url: URL_NP21_FLOWLINES,
                onEachFeature: FLonEachFeature
            });
        FLOWLINES_LAYER.setStyle({
            color: "blue",
            fillOpacity: 0,
            weight: 1,
        });

        //The map overlay
        const OVERLAY_MAPS = {
            "HUC8 Boundaries": BOUNDARIES_LAYER,
            "Catchments": CATCHMENTS_LAYER,
            "Flow Lines": FLOWLINES_LAYER,
            "NWS Lake/Res": WB_LAYER,
            "Gauges": markersBar,
        };
        const LAYER_OPTIONS = L.control.layers(Base_Maps, OVERLAY_MAPS);
        LAYER_OPTIONS.addTo(MAP);

        // Can send a message containing the coordniates where the user clicked on the map
        /*
        function handleMapClick(e) {
            const LAT_LNG = e.latlng;
            if(!MAP.hasLayer(CATCHMENTS_LAYER)){
                sendMessageToDotnet(
                    `Message from map click lat: ${LAT_LNG.lat}, lng: ${LAT_LNG.lng}`
                );
            }

            //alert("You clicked the map at " + e.latlng);
        }
        MAP.on("click", handleMapClick);*/

        //Concatenates 2 geojsons
        function concatGeoJSON(g1, g2) {
            return {
                "type": "FeatureCollection",
                "features": [...g1.features, ...g2.features]
            }
        }

        // app interaction
        function AddGeoJSON(gstr) {
            flowline = JSON.parse(gstr).stream_geometry;  //stream segments only
            if (allShapes == null) allShapes = flowline
            else allShapes = concatGeoJSON(allShapes, flowline);
            // sendMessageToDotnet(gstr);
        }

        //Adds a waterbody geojson to the existing one allShapes through concatenation
        function AddWBGeoJSON(gstr) {
            wb = JSON.parse(gstr);
            if (allShapes == null) allShapes = wb
            else allShapes = concatGeoJSON(allShapes, wb);
        }

        //Used to apply specific properties to every feature within a layer
        function onEachFeature(feature, layer) {
            layer.on('click', function (e) {
                if (layer.feature.properties.COMID != null) sendMessageToDotnet(layer.feature.properties.COMID.toString());
            });

            if (layer.feature.properties.COMID != null) {
                var str = '';
                if (feature.properties.GNIS_NAME != null) str = ", " + feature.properties.GNIS_NAME.toString();
                if (str == ' ') str = '';
                str = feature.properties.COMID.toString() + str;
                layer.bindTooltip(str, {
                    permanent: false,
                    opacity: 1.0
                });
            };
        }

        //Renders a geoJson allShapes within the map and fits the bounds around it
        function renderGeoJSON() {
            if (allShapes != null) {
                geoLayer = L.geoJSON(allShapes,
                    {
                        onEachFeature: onEachFeature
                    });
                geoLayer.setStyle({ weight: 2 });
                geoLayer.eachLayer(function (layer) {
                    if (layer.feature.geometry.type == 'Polygon') {
                        layer.setStyle({ color: 'navy', weight: 2 })
                    }
                });
                geoLayer.addTo(MAP);
                MAP.addLayer(markers);

                MAP.fitBounds(geoLayer.getBounds());
            }
        }

        //Colors a specific COMID's geojson line to another color
        function ColorGeoJSON(COMID, linecolor) {
            geoLayer.eachLayer(function (layer) {
                if (layer.feature.properties.COMID == COMID) {
                    layer.setStyle({ color: linecolor });
                }
            })
        }

        //Used to remove a geojson from the map completely
        function eraseGeoJSON() {
            if (geoLayer != null) MAP.removeLayer(geoLayer);
            markers.clearLayers();
            allShapes = null;
            geoLayer = null; // new L.geoJSON;
        }

        //Green and red icons for markers
        var greenIcon = new L.Icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            iconSize: [15, 25],
            iconAnchor: [6, 25],
            popupAnchor: [1, -25],
            shadowSize: [25, 25]
        });
        var redIcon = new L.Icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            iconSize: [15, 25],
            iconAnchor: [6, 25],
            popupAnchor: [1, -25],
            shadowSize: [25, 25]
        });

        //Used to add specific markers to the map as either green or red
        function AddMarker(mcolor, long, lat, msg) {
            var marker;
            if (mcolor == "green") marker = L.marker([lat, long], { icon: greenIcon });
            else marker = L.marker([lat, long], { icon: redIcon });
            marker.bindTooltip(msg);
            markers.addLayer(marker);
        }

        //Used to enable or disable markers
        function Bounds(showstr) {
            if (showstr == "True") MAP.addLayer(markers);
            else MAP.removeLayer(markers);
        }

        // dotnet <=> js message handlers
        /*
        window.addEventListener('DOMContentLoaded', (event) => {
            window.chrome.webview.postMessage('DOMContentLoaded');
        });
        */

        //Event listener used to determine what function will be performed depending on message received from Dotnet code
        window.chrome.webview.addEventListener("message", (event) => {
            var messageArr = event.data.split("|");
            //Currently unused event listener code blocks
            // if (messageArr[0] == "ADD") AddGeoJSON(messageArr[1]);
            // if (messageArr[0] == "ADDWB") AddWBGeoJSON(messageArr[1]);
            // if (messageArr[0] == "RENDER") renderGeoJSON();
            // if (messageArr[0] == "ERASE") eraseGeoJSON();
            // if (messageArr[0] == "COLOR") ColorGeoJSON(parseInt(messageArr[1]), messageArr[2]);
            // if (messageArr[0] == "MARKER") AddMarker(messageArr[1], messageArr[2], messageArr[3], messageArr[4]);
            // if (messageArr[0] == "BOUNDS") Bounds(messageArr[1]);
            if (messageArr[0] == "FocusOn") focusOn(messageArr[1]);
            if (messageArr[0] == "FocusOnGauge") focusOnGauge(messageArr[1]);
            if (messageArr[0] == "SwitchSearch") switchSearch(messageArr[1]);
            //if (messageArr[0] == "CheckGauge") 

            //                console.log(`message from dotnet: ${event.data}`);
            //                this.document.getElementById("message-bar").innerHTML =
            //                    event.data;
        });

        //Sends a message to the Dotnet side of code
        function sendMessageToDotnet(message) {
            window.chrome.webview.postMessage(message);
            console.log(message);

            //alert(message);
        }
        
        //Focuses map on desired comid
        //Sends alert to webivew if there is no comid
        function focusOn(comval) {
            try{
                let comid = parseInt(comval);
                makeSelectedLayer(comid);
                let coords = catchRequest(comid)[1];
                MAP.setView([coords[1], coords[0]], 12);
            }
            catch(err){
                console.log(err);
                alert("COMID does not exist or was entered incorrectly");
            }
        }

        //Focuses map on desired gauge while also checking to see if gauge exists.
        //Sends alert to webview if gauge does not exist
        function focusOnGauge(gaugeID){
            try{
                for(let item of geoUSData.features){
                    if(parseInt(gaugeID) == parseInt(item.properties.SOURCE_FEA)){
                        let coords = item.geometry.coordinates;
                        MAP.setView([coords[1], coords[0]], 13);
                        break;
                    }
                }
            }
            catch(err){
                console.log(err);
                sendMessageToDotnet("noGauge|" + gaugeID);
                alert("Gauge does not exist or was entered incorrectly");
            }
        }

        //Turns a comid clicked by the user into a "selected" comid by making a new layer that contains the original comid's metadata, but is colored black instead
        function makeSelectedLayer(comid) {
            //Ensures it is not adding multiple of the same layer or overlay. 
            if (SELECTED_LAYER) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                MAP.removeLayer(SELECTED_LAYER);
                LAYER_OPTIONS.removeLayer(SELECTED_LAYER);
            }
            
            //Pull catchment geometry data from watersgeo
            let comData = catchRequest(comid);
            
            SELECTED_LAYER = L.layerGroup();
            for (let element of comData[0]) {
                //Creates a new feature using the JSON
                let newFeature = L.geoJSON(element[1])
                    .bindTooltip(function (layer){
                        return layer.feature.properties.FEATUREID.toString();
                    }, { opacity: 1.0 }
                    ).addTo(SELECTED_LAYER);

                newFeature.setStyle({
                    color: "black",
                    fillOpacity: 0.1,
                });
            }

            SELECTED_LAYER.addTo(MAP);

            LAYER_OPTIONS.addOverlay(SELECTED_LAYER, "Selected Catchments");
        }

        //Used to pull catchment data such as coordinates and geometry from watersgeo
        function catchRequest(comid){
            let coords = [0,0];
            let geoJSONCatchList = [];

            let catchment_url_base =
            "https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/Catchments_NP21_Simplified/MapServer/0/query?where=FEATUREID%3D";
            let catchment_url_extension =
            "&text=&objectIds=&time=&timeRelation=esriTimeRelationOverlaps&geometry=&geometryType=esriGeometryEnvelope&inSR=&spatialRel=esriSpatialRelIntersects&distance=&units=esriSRUnit_Foot&relationParam=&outFields=*&returnGeometry=true&returnTrueCurves=false&maxAllowableOffset=&geometryPrecision=&outSR=&havingClause=&returnIdsOnly=false&returnCountOnly=false&orderByFields=&groupByFieldsForStatistics=&outStatistics=&returnZ=false&returnM=false&gdbVersion=&historicMoment=&returnDistinctValues=false&resultOffset=&resultRecordCount=&returnExtentOnly=false&sqlFormat=none&datumTransformation=&parameterValues=&rangeValues=&quantizationParameters=&featureEncoding=esriDefault&f=geojson";
            
            let catchment_query_url = catchment_url_base + comid + catchment_url_extension;

            $.ajax({
            async: false,
            type: "GET",
            url: catchment_query_url,
            success: function (data, textStatus, jqXHR) {
                //console.log(data);

                if (Object.entries(data)[1][1][0].geometry.type === "MultiPolygon") {
                    let firstEntries = Object.entries(data)[1][1][0].geometry.coordinates[0][0][0];
                    coords = firstEntries;
                } else {
                    let firstEntries = Object.entries(data)[1][1][0].geometry.coordinates[0][0];
                    coords = firstEntries;
                }

                geoJSONCatchList.push([comid, data]);
            },
            });
            
            let val = [geoJSONCatchList, coords];
            return val;
        }

        //Retrieves coordinates for comid and focuses map on it
        //Sends alert to webview if comid does not exist
        function comidClick(){
            //console.log("clicked");
            try {
                let comval = document.getElementById("searchBox").value;
                let comid = parseInt(comval);

                let coords = catchRequest(comid)[1];
                
                //console.log(coords);
                //alert(coords);
                MAP.setView([coords[1], coords[0]], 12);
            }
            catch(err) {
                console.log(err);
                alert("COMID does not exist or was entered incorrectly");
            }
        }
        
        //Used to move map to specific coordinates in order to make navigation easier
        function coordsClick(){
            let lat = document.getElementById("latBox");
            let lon = document.getElementById("lonBox");
            MAP.setView([lat.value, lon.value], 12);
        }

        //Used to search for and focus on a specific gauge
        function gaugeClick(){
            let gaugeval = document.getElementById("searchBox").value;
            focusOnGauge(gaugeval);
        }

        //Used to change the searchbox attributes for use with either comid or gauge depending on the tab the user has open in forms
        function switchSearch(searchType){
            if(searchType == "comid"){
                let textBox = document.getElementById("searchBox");
                textBox.value = "";
                textBox.setAttribute("placeholder", "COMID");
                let searchButton = document.getElementById("searchButton");
                searchButton.innerHTML = "COMID Search";
                searchButton.setAttribute("onclick", "comidClick()");
            }
            else{
                let textBox = document.getElementById("searchBox");
                textBox.value = "";
                textBox.setAttribute("placeholder", "GaugeID");
                let searchButton = document.getElementById("searchButton");
                searchButton.innerHTML = "Gauge Search";
                searchButton.setAttribute("onclick", "gaugeClick()");
            }
        }
    </script>
</body>
</html>