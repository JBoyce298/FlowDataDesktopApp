<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <title>Leaflet-WebView2 test</title>
    <meta name="viewport"
          content="width=device-width, initial-scale=1, shrink-to-fit=no" />

    <link rel="stylesheet" href="main.css" />
    <!-- Leaflet stuff -->

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.8.0/dist/leaflet.css" integrity="sha512-hoalWLoI8r4UszCkZ5kL8vayOGVae1oxXe/2A4AO6J9+580uKHDO3JdHb7NzwwzK5xr/Fs0W40kiNHxM9vyTtQ==" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.8.0/dist/leaflet.js" integrity="sha512-BB3hKbKWOc9Ez/TAwyWxNXeoV9c1v6FIeYiBieIWkpLjauysF18NzgR1MBNBXf8/KABdlkX68nAhlwcDFLGPCQ==" crossorigin=""></script>
    <script src="https://unpkg.com/esri-leaflet@2.2.3/dist/esri-leaflet.js"
            integrity="sha512-YZ6b5bXRVwipfqul5krehD9qlbJzc6KOGXYsDjU9HHXW2gK57xmWl2gU6nAegiErAqFXhygKIsWPKbjLPXVb2g=="
            crossorigin=""></script>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <!--<script src="gaugeGeoData.js"></script>-->

    <style> 

    .leaflet-tooltip { padding: 2px; }
        #map_container {
            background: white;
        }

    </style>

</head>

<body>
    <div id="search_bar">
        <!--Potential search for COMID button before actually pulling data. Gives CORS privelege error currently-->
            <input id="comidBox" type="text" placeholder="COMID" style="width: 70px">
            <button id="comidButton" type="submit" onclick="comidClick()">COMID Search</button>
        
            <input id="latBox" type="text" placeholder="Latitude" style="width: 70px">
            <input id="lonBox" type="text" placeholder="Longitude" style="width: 70px">
            <button id="coordsButton" type="submit" onclick="coordsClick()">Coords Search</button>
    </div>
    <!--<br>-->
    <div id="map_container">
        <div id="map"></div>
    </div>
    <p class="hidden" id="comid" value=""></p>
    <p class="hidden" id="lat" value=""></p>
    <p class="hidden" id="lon" value=""></p>
    <script src="./gage_geo.js"></script>
    <script src="./gage_shape.js"></script>
    <script src="./newergeo.js"></script>
    <script src="./Autolinker.min.js"></script>
    <link rel="stylesheet" href="markers\MarkerCluster.css"></script>
    <link rel="stylesheet" href="markers\MarkerCluster.Default.css"></script>
    <script src="markers\leaflet.markercluster-src.js"></script>
    <script src="markers\MarkerCluster.js"></script>
    <script>
        //import features from './NHDPlusV21_US_gage.json' assert {type: 'json'};

        //console.log(features);

        //let gaugeJson = ;

        var allShapes = null;
        var geoLayer;
        let SELECTED_LAYER = null;

        const DEFAULT_LAT = document.getElementById("lat").value;
        const DEFAULT_LNG = document.getElementById("lat").value;
        const DEFAULT_ZOOM = 13;
        // NWS Waterbodies
        const URL_NWS_WB =
            "https://mapservices.weather.noaa.gov/static/rest/services/nws_reference_maps/NWM_Lakes_and_Reservoirs/MapServer/0";
        // catchments
        const URL_NP21_CATCHMENTS =
            "https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/Catchments_NP21_Simplified/MapServer/0";
        // WBD - HUC_8
        const URL_NP21_HUC8 =
            "https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/WBD_NP21_Simplified/MapServer/2";
        // flowlines
        const URL_NP21_FLOWLINES =
            "https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/NHDSnapshot_NP21/MapServer/0";

        const GEO_TILE_SET = 
            "https://studio.mapbox.com/tilesets/boycejr.d85fvy9x";

        // build base map layer
        var MAP = L.map("map").fitBounds([
            [49.5, -125.02],
            [23.73, -69.05]
        ]);
        MAP.setView([33.882446, -83.654709], 12);

        var markers = L.layerGroup();

        const CenterBox = L.Control.extend({
            options: {
                position: 'bottomright'
            },
            onAdd: function (MAP) {
                return L.DomUtil.create('div', 'center-box');
            },
            setContent: function (content) {
                this.getContainer().innerHTML = 'Map Center: ' + content;
            }
        });

        var centerBox = new CenterBox().addTo(MAP);

        function LatLngToArrayString(ll) {
            return "[" + ll.lat.toFixed(5) + ", " + ll.lng.toFixed(5) + "]";
        }

        MAP.on("layeradd", function (event) {
            if (geoLayer != null) { geoLayer.bringToFront(); }
        });

        MAP.on('moveend', function () {
            centerBox.setContent(LatLngToArrayString(MAP.getCenter()));
        });

        const LIGHT_GRAY = L.tileLayer("https://server.arcgisonline.com/arcgis/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}", {
            attribution:
                'Sources: Esri, HERE, Garmin, (c) OpenStreetMap contributors, and the GIS user community',
        });

        const STREETVIEW = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
        }).addTo(MAP);

        const NAT_GEO = L.tileLayer(
            "https://server.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}",
            {
                attribution:
                    "Tiles &copy; Esri &mdash; National Geographic, Esri, DeLorme, NAVTEQ, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, iPC",
            }
        );

        const SATELLITE = L.tileLayer(
            "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
            {
                attribution:
                    "Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community",
            }
        );

        const Base_Maps = {
            "No Map": L.tileLayer(''),
            "Streetview": STREETVIEW,
            "Light Gray": LIGHT_GRAY,
            "ESRI Natl. Geo.": NAT_GEO,
            "ESRI Imagery": SATELLITE,
        };
        //            const BASE_OPTIONS = L.control.layers()
        //((null, Base_Maps);
        //BASE_OPTIONS.addTo(MAP);


        const WB_LAYER = L.esri
            .featureLayer({
                url: URL_NWS_WB,
                onEachFeature: WBonEachFeature
            }
            );

        const CATCHMENTS_LAYER = L.esri
            .featureLayer({
                url: URL_NP21_CATCHMENTS,
                onEachFeature: CatchonEachFeature
            });
        CATCHMENTS_LAYER.setStyle({
            color: "orange",
            fillOpacity: 0,
            weight: 1,
        });//.addTo(MAP);

        //let pathName = window.location.pathname;

        // var req = new XMLHttpRequest();
        // req.onload = function(){
        //     testP = this.responseText;
        // };
        // req.open('GET', './NHDPlusV21_US_gage.geojson');
        // req.send();

        //const textGauge = fetch('./NHDPlusV21_US_gage.json');
        //console.log(gaugeJson);



        // let dirName = document.getElementById("directoryName");
        // dirName.innerHTML = testP;
        //var gaugeGeo = FileReader.;
        //var orangeIcon =  new LeafIcon({iconUrl: 'NHDPlusV21_US_gage_0.png'});
        // $.getJSON(shapeUSData, function(data) {
        //    var my_json = L.geoJson(data, {
        //     pointToLayer: function(feature, latlng) {
        //         var smallIcon = L.Icon({
        //             options: {
        //                 iconSize: [27, 27],
        //                 iconAnchor: [13, 27],
        //                 popupAnchor:  [1, -24],
        //                 iconUrl: 'NHDPlusV21_US_gage_0.png'
        //             }
        //         });
        //         return L.marker(latlng, {icon: smallIcon});
        //     },
        //    onEachFeature: function (feature, layer) {
        //            layer.bindPopup(feature.properties.ATT1 + '<br />'
        //                                          + feature.properties.ATT2);
        //    }
        //  });
        // my_json.addTo(markers.addTo(map));
        // TOC.addOverlay(my_json, "My layer name in TOC");
        // map.removeLayer(my_json); 
        // });
        var autolinker = new Autolinker({truncate: {length: 30, location: 'smart'}});
        function removeEmptyRowsFromPopupContent(content, feature) {
         var tempDiv = document.createElement('div');
         tempDiv.innerHTML = content;
         var rows = tempDiv.querySelectorAll('tr');
         for (var i = 0; i < rows.length; i++) {
             var td = rows[i].querySelector('td.visible-with-data');
             var key = td ? td.id : '';
             if (td && td.classList.contains('visible-with-data') && feature.properties[key] == null) {
                 rows[i].parentNode.removeChild(rows[i]);
             }
         }
         return tempDiv.innerHTML;
        }
        document.querySelector(".leaflet-popup-pane").addEventListener("load", function(event) {
          var tagName = event.target.tagName,
            popup = MAP._popup;
          // Also check if flag is already set.
          if (tagName === "IMG" && popup && !popup._updated) {
            popup._updated = true; // Set flag to prevent looping.
            popup.update();
          }
        }, true);
        var bounds_group = new L.featureGroup([]);
        function pop_NHDPlusV21_US_gage_0(feature, layer) {
            /*
                    <tr>\
                        <td colspan="2">' + (feature.properties['REACHCODE'] !== null ? autolinker.link("REACHCODE: " + feature.properties['REACHCODE'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['REACHRESOL'] !== null ? autolinker.link("REACHRESOL: " + feature.properties['REACHRESOL'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['Measure'] !== null ? autolinker.link("Measure: " + feature.properties['Measure'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['STATE_CD'] !== null ? autolinker.link("STATE_CD: " + feature.properties['STATE_CD'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['STATE'] !== null ? autolinker.link("STATE: " + feature.properties['STATE'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['ActiveDate'] !== null ? autolinker.link("ActiveDate: " + (dateUNIXConvert(feature.properties['ActiveDate'].toLocaleString()))) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['GagesII'] !== null ? autolinker.link("GagesII: " + feature.properties['GagesII'].toLocaleString()) : '') + '</td>\
                    </tr>\
            */
            var popupContent = '<table>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['SOURCE_FEA'] !== null ? autolinker.link("SOURCE_FEA: " + feature.properties['SOURCE_FEA'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['Active'] !== null ? autolinker.link("Active: " + (parseInt(feature.properties['Active'].toLocaleString()) == 1 ? "True" : "False")) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['OBJECTID'] !== null ? autolinker.link("OBJECTID: " + feature.properties['OBJECTID'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['SOURCE_ORI'] !== null ? autolinker.link("SOURCE_ORI: " + feature.properties['SOURCE_ORI'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['FEATUREDET'] !== null ? autolinker.link("FEATUREDET: " + feature.properties['FEATUREDET'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['EventType'] !== null ? autolinker.link("EventType: " + feature.properties['EventType'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['FLComID'] !== null ? autolinker.link("FLComID: " + feature.properties['FLComID'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['AGENCY_CD'] !== null ? autolinker.link("AGENCY_CD: " + feature.properties['AGENCY_CD'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['STATION_NM'] !== null ? autolinker.link("STATION_NM: " + feature.properties['STATION_NM'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['DASqMi'] !== null ? autolinker.link("DASqMi: " + feature.properties['DASqMi'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['DASqKm'] !== null ? autolinker.link("DASqKm: " + feature.properties['DASqKm'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['LatSite'] !== null ? autolinker.link("LatSite: " + feature.properties['LatSite'].toLocaleString()) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <td colspan="2">' + (feature.properties['LonSite'] !== null ? autolinker.link("LonSite: " + feature.properties['LonSite'].toLocaleString()) : '') + '</td>\
                    </tr>\
                </table>';
            layer.bindPopup(popupContent, {maxHeight: 400});
            var popup = layer.getPopup();
            var content = popup.getContent();
            var updatedContent = removeEmptyRowsFromPopupContent(content, feature);
            popup.setContent(updatedContent);
        }

        function dateUNIXConvert(unixTime){
            var timeInt = parseInt(unixTime);
            let dateObj = new Date(timeInt * 1000);
            let utcString = dateObj.toUTCString();
            return utcString;
        }

        //green
        function activeGauge() {
            return {
                pane: 'pane_NHDPlusV21_US_gage_0',
                radius: 4.0,
                opacity: 1,
                color: 'rgba(35,35,35,1.0)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1,
                fill: true,
                fillOpacity: 1,
                fillColor: 'rgba(6,193,0,1.0)',
                //purple: fillColor: 'rgba(179,18,219,1.0)',
                //orange: fillColor: 'rgba(231,113,72,1.0)',
                interactive: true,
            }
        }

        //red
        function inactiveGauge() {
            return {
                pane: 'pane_NHDPlusV21_US_gage_0',
                radius: 4.0,
                opacity: 1,
                color: 'rgba(35,35,35,1.0)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1,
                fill: true,
                fillOpacity: 1,
                fillColor: 'rgba(210,11,11,1.0)',
                interactive: true,
            }
        }

        MAP.createPane('pane_NHDPlusV21_US_gage_0');
        MAP.getPane('pane_NHDPlusV21_US_gage_0').style.zIndex = 400;
        MAP.getPane('pane_NHDPlusV21_US_gage_0').style['mix-blend-mode'] = 'normal';
        var GAUGE_LAYER = new L.geoJson(geoUSData, {
            attribution: '',
            interactive: true,
            dataVar: 'geoUSData',
            layerName: 'GAUGE_LAYER',
            pane: 'pane_NHDPlusV21_US_gage_0',
            onEachFeature: pop_NHDPlusV21_US_gage_0,
            pointToLayer: function (feature, latlng) {
                var context = {
                    feature: feature,
                    variables: {}
                };
                if(parseInt(feature.properties['Active']) == 1){
                    return L.circleMarker(latlng, activeGauge(feature));
                }
                else{
                    return L.circleMarker(latlng, inactiveGauge(feature));
                }
                
            },
        });
        var markersBar = L.markerClusterGroup();
        markersBar.addLayer(GAUGE_LAYER);
        /*
        markersBar.setStyle([
            {
                url: 'markers/m1.png',
                height: 50,
                width: 50
            },
            {
                url: 'markers/m2.png',
                height: 50,
                width: 50
            },
            {
                url: 'markers/m3.png',
                height: 50,
                width: 50
            },
            {
                url: 'markers/m4.png',
                height: 50,
                width: 50
            },
            {
                url: 'markers/m5.png',
                height: 50,
                width: 50
            }
            ]);
            */
        markersBar.addTo(MAP);
        //const GAUGE_LAYER = L.geoJSON(shapeUSData).addTo(MAP);
        // const GAUGE_IMAGE = L.imageOverlay('gaugeimage.png', [[-0.984152017, 85.291363022],
        //     [-199.327951806, -20.167508032]]).addTo(MAP);
        // var accesstoken = "";
        // const GAUGE_LAYER = L.esri
        //     .featureLayer({
        //         url: GEO_TILE_SET,
        //         //onEachFeature: CatchonEachFeature
        //     });
        // GAUGE_LAYER.setStyle({
        //     color: "purple",
        // }).addTo(MAP);
        // const arrayOfMarkers = results.value.map(element => 
        //     L.marker([element.Latitude, element.Longitude]).bindPopup(/* etc. */)
        // );
        // const mcg = L.markerClusterGroup();
        // mcg.addLayers(arrayOfMarkers);
        // mcg.addTo(map);
            //onEachFeature: GaugeonEachFeature
        // GAUGE_LAYER.setStyle({
        //     color: "purple",
        //     fillOpacity: 0,
        //     weight: 1,
        // }).addTo(MAP);
        
        // CONTAMINANT_LAYER = L.layerGroup();
        // for (let element of geoJSONCatchList) {
        //     //Creates a new feature using the JSON
        //     let newFeature = L.geoJSON(element[1]).addTo(CONTAMINANT_LAYER);

        //     newFeature.setStyle({
        //         color: "black",
        //         fillOpacity: 0.1,
        //     });
        // }
        // for (let element of geoJSONFlowList) {
        //     //Creates a new feature using the JSON
        //     let newFeature = L.geoJSON(element[1]).addTo(CONTAMINANT_LAYER);
        //     //Loops through times when catchments were first contaminated
        //     const contaminateCatchment = timeWhenTrue.find((catchment) => {
        //         return catchment[0] === element[0];
        //     });
        //     //Checks Com ID to ensure the correct geometry is changing color
        //     if (contaminateCatchment && contaminateCatchment[1] <= smallDateStrings[dateSlider.value]) {
        //         //If Catchment is contaminated at current time, it will appear red
        //         newFeature.setStyle({
        //             color: "red",
        //         });
        //     } else {
        //         newFeature.setStyle({
        //             color: "blue",
        //         });
        //     }
        // }
        // //Checks to see if the layer should be re-added to the map
        // if (contaminateLayerOn) {
        //     CONTAMINANT_LAYER.addTo(MAP);
        // }

        /*
        const SELECTED_LAYER = L.esri
            .featureLayer({
                onEachFeature: CatchonEachFeature
            });
        SELECTED_LAYER.setStyle({
            color: "black",
            fillOpacity: 0,
            weight: 1,
        })
        */
        function GaugeonEachFeature(feature, layer) {
            return null;
        }

        function CatchonEachFeature(feature, layer) {
            layer.on('click', function (e) {
                try{
                    if (layer.feature.properties.FEATUREID != null) sendMessageToDotnet(layer.feature.properties.FEATUREID.toString());
                }
                catch{

                }
                //sendMessageToDotnet(layer.feature.properties.toString());

                //ChangeFeatureColor(feature, layer);
                makeSelectedLayer(layer.feature.properties.FEATUREID);
                let docComId = document.getElementById("comid");
                docComId.setAttribute("value", layer.feature.properties.FEATUREID.toString());
            });

            if (layer.feature.properties.FEATUREID != null){
                var str = layer.feature.properties.FEATUREID.toString();
                layer.bindTooltip(str, { opacity: 1.0 });
            }

            
        };

        function WBonEachFeature(feature, layer) {
            if (layer.feature.properties.GNIS_NAME != null) {
                var str = layer.feature.properties.GNIS_NAME.toString();
                if (str != ' ') { layer.bindTooltip(str, { permanent: false, opacity: 1.0 }); };
            };
        };

        function FLonEachFeature(feature, layer) {
            if ((feature.properties.FCODE == 56600) || (feature.properties.FLOWDIR == 0)) {
                layer.setStyle({ opacity: 0.0 });
                return;
            };

            if (layer.feature.properties.COMID != null) {
                var str = '';
                if (layer.feature.properties.GNIS_NAME != null) str = ", " + layer.feature.properties.GNIS_NAME.toString();
                if (str == ' ') str = '';
                str = layer.feature.properties.COMID.toString() + str;
                layer.bindTooltip(str, { opacity: 1.0 });
            };

            layer.on('click', function (e) {
                if (layer.feature.properties.COMID != null) sendMessageToDotnet(layer.feature.properties.COMID.toString());
                //sendMessageToDotnet(layer.feature.properties.toString());

                //ChangeFeatureColor(feature, layer);
                makeSelectedLayer(layer.feature.properties.COMID);
                let docComId = document.getElementById("comid");
                docComId.setAttribute("value", layer.feature.properties.COMID.toString());
            });
        };

        // build map layers
        /*.on('click', function (e) {
        // Check for selected
            if (selected) {
        // Reset selected to default style
            e.target.resetStyle(selected)
            }
            // Assign new selected
            selected = e.layer
            // Bring selected to front
            selected.bringToFront()
            // Style selected
            selected.setStyle({
                'color': 'red'
            })
        }).addTo(map);*/



        const BOUNDARIES_LAYER = L.esri
            .featureLayer({
                url: URL_NP21_HUC8,
            });
        BOUNDARIES_LAYER.setStyle({
            color: "red",
            fillOpacity: 0,
            weight: 1,
        });

        const FLOWLINES_LAYER = L.esri
            .featureLayer({
                url: URL_NP21_FLOWLINES,
                onEachFeature: FLonEachFeature
            });
        FLOWLINES_LAYER.setStyle({
            color: "blue",
            fillOpacity: 0,
            weight: 1,
        });


        const OVERLAY_MAPS = {
            "HUC8 Boundaries": BOUNDARIES_LAYER,
            "Catchments": CATCHMENTS_LAYER,
            "Flow Lines": FLOWLINES_LAYER,
            "NWS Lake/Res": WB_LAYER,
            "Gauges": markersBar,
        };
        const LAYER_OPTIONS = L.control.layers(Base_Maps, OVERLAY_MAPS);
        LAYER_OPTIONS.addTo(MAP);

        // app interaction
        /*
        function handleMapClick(e) {
            const LAT_LNG = e.latlng;
            if(!MAP.hasLayer(CATCHMENTS_LAYER)){
                sendMessageToDotnet(
                    `Message from map click lat: ${LAT_LNG.lat}, lng: ${LAT_LNG.lng}`
                );
            }

            //alert("You clicked the map at " + e.latlng);
        }
        MAP.on("click", handleMapClick);*/

        function concatGeoJSON(g1, g2) {
            return {
                "type": "FeatureCollection",
                "features": [...g1.features, ...g2.features]
            }
        }

        // app interaction
        function AddGeoJSON(gstr) {
            flowline = JSON.parse(gstr).stream_geometry;  //stream segments only
            if (allShapes == null) allShapes = flowline
            else allShapes = concatGeoJSON(allShapes, flowline);
            // sendMessageToDotnet(gstr);
        }

        function AddWBGeoJSON(gstr) {
            wb = JSON.parse(gstr);
            if (allShapes == null) allShapes = wb
            else allShapes = concatGeoJSON(allShapes, wb);
        }

        function onEachFeature(feature, layer) {
            layer.on('click', function (e) {
                if (layer.feature.properties.COMID != null) sendMessageToDotnet(layer.feature.properties.COMID.toString());
            });

            if (layer.feature.properties.COMID != null) {
                var str = '';
                if (feature.properties.GNIS_NAME != null) str = ", " + feature.properties.GNIS_NAME.toString();
                if (str == ' ') str = '';
                str = feature.properties.COMID.toString() + str;
                layer.bindTooltip(str, {
                    permanent: false,
                    opacity: 1.0
                });
            };
        }

        function renderGeoJSON() {
            if (allShapes != null) {
                geoLayer = L.geoJSON(allShapes,
                    {
                        onEachFeature: onEachFeature
                    });
                geoLayer.setStyle({ weight: 2 });
                geoLayer.eachLayer(function (layer) {
                    if (layer.feature.geometry.type == 'Polygon') {
                        layer.setStyle({ color: 'navy', weight: 2 })
                    }
                });
                geoLayer.addTo(MAP);
                MAP.addLayer(markers);

                MAP.fitBounds(geoLayer.getBounds());
            }
        }

        function ColorGeoJSON(COMID, linecolor) {
            geoLayer.eachLayer(function (layer) {
                if (layer.feature.properties.COMID == COMID) {
                    layer.setStyle({ color: linecolor });
                }
            })
        }

        function eraseGeoJSON() {
            if (geoLayer != null) MAP.removeLayer(geoLayer);
            markers.clearLayers();
            allShapes = null;
            geoLayer = null; // new L.geoJSON;
        }

        var greenIcon = new L.Icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            iconSize: [15, 25],
            iconAnchor: [6, 25],
            popupAnchor: [1, -25],
            shadowSize: [25, 25]
        });
        var redIcon = new L.Icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            iconSize: [15, 25],
            iconAnchor: [6, 25],
            popupAnchor: [1, -25],
            shadowSize: [25, 25]
        });

        function AddMarker(mcolor, long, lat, msg) {
            var marker;
            if (mcolor == "green") marker = L.marker([lat, long], { icon: greenIcon });
            else marker = L.marker([lat, long], { icon: redIcon });
            marker.bindTooltip(msg);
            markers.addLayer(marker);
        }

        function Bounds(showstr) {
            if (showstr == "True") MAP.addLayer(markers);
            else MAP.removeLayer(markers);
        }

        function Labels(boostr) {
            var permanentlabels = false;
            if (boostr == "True") permanentlabels = true;

            geoLayer.eachLayer(function (layer) {
                if (layer.feature.properties.COMID != null) {
                    var str = '';
                    if (layer.feature.properties.GNIS_NAME != null) str = ", " + layer.feature.properties.GNIS_NAME.toString();
                    if (str == ' ') str = '';
                    str = layer.feature.properties.COMID.toString() + str;
                    if (str != ' ') { layer.unbindTooltip(); layer.bindTooltip(str, { permanent: permanentlabels, opacity: 1.0 }); };
                }
            });
        }

        // dotnet <=> js message handlers
        /*
        window.addEventListener('DOMContentLoaded', (event) => {
            window.chrome.webview.postMessage('DOMContentLoaded');
        });
        */

        window.chrome.webview.addEventListener("message", (event) => {
            var messageArr = event.data.split("|");
            if (messageArr[0] == "ADD") AddGeoJSON(messageArr[1]);
            if (messageArr[0] == "ADDWB") AddWBGeoJSON(messageArr[1]);
            if (messageArr[0] == "RENDER") renderGeoJSON();
            if (messageArr[0] == "ERASE") eraseGeoJSON();
            if (messageArr[0] == "COLOR") ColorGeoJSON(parseInt(messageArr[1]), messageArr[2]);
            if (messageArr[0] == "MARKER") AddMarker(messageArr[1], messageArr[2], messageArr[3], messageArr[4]);
            if (messageArr[0] == "BOUNDS") Bounds(messageArr[1]);
            if (messageArr[0] == "LABELS") Labels(messageArr[1]);
            if (messageArr[0] == "FocusOn") focusOn(messageArr[1]);

            //                console.log(`message from dotnet: ${event.data}`);
            //                this.document.getElementById("message-bar").innerHTML =
            //                    event.data;
        });

        function sendMessageToDotnet(message) {
            window.chrome.webview.postMessage(message);
            console.log(message);

            //alert(message);
        }
        
        function focusOn(comval) {
            let comid = parseInt(comval);
            makeSelectedLayer(comid);
            let coords = catchRequest(comid);
            MAP.setView([coords[1], coords[0]], 12);
        }

        function makeSelectedLayer(comid) {
            //Ensures it is not adding multiple of the same layer or overlay. 
            if (SELECTED_LAYER) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                MAP.removeLayer(SELECTED_LAYER);
                LAYER_OPTIONS.removeLayer(SELECTED_LAYER);
            }
            
            //Pull catchment geometry data from watersgeo
            let coords = [];
            let geoCoordsList = [];
            let geoJSONCatchList = [];

            let catchment_url_base =
            "https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/Catchments_NP21_Simplified/MapServer/0/query?where=FEATUREID%3D";
            let catchment_url_extension =
            "&text=&objectIds=&time=&timeRelation=esriTimeRelationOverlaps&geometry=&geometryType=esriGeometryEnvelope&inSR=&spatialRel=esriSpatialRelIntersects&distance=&units=esriSRUnit_Foot&relationParam=&outFields=*&returnGeometry=true&returnTrueCurves=false&maxAllowableOffset=&geometryPrecision=&outSR=&havingClause=&returnIdsOnly=false&returnCountOnly=false&orderByFields=&groupByFieldsForStatistics=&outStatistics=&returnZ=false&returnM=false&gdbVersion=&historicMoment=&returnDistinctValues=false&resultOffset=&resultRecordCount=&returnExtentOnly=false&sqlFormat=none&datumTransformation=&parameterValues=&rangeValues=&quantizationParameters=&featureEncoding=esriDefault&f=geojson";
            
            let catchment_query_url = catchment_url_base + comid + catchment_url_extension;

            $.ajax({
            async: false,
            type: "GET",
            url: catchment_query_url,
            success: function (data, textStatus, jqXHR) {
                //console.log(data);

                if (Object.entries(data)[1][1][0].geometry.type === "MultiPolygon") {
                    let firstEntries = Object.entries(data)[1][1][0].geometry.coordinates[0][0][0];
                    coords = firstEntries;
                } else {
                    let firstEntries = Object.entries(data)[1][1][0].geometry.coordinates[0][0];
                    coords = firstEntries;
                }

                geoJSONCatchList.push([comid, data]);
            },
            });
            geoCoordsList.push([comid, coords]);

            //alert(coords);
            
            SELECTED_LAYER = L.layerGroup();
            for (let element of geoJSONCatchList) {
                //Creates a new feature using the JSON
                let newFeature = L.geoJSON(element[1])
                    .bindTooltip(function (layer){
                        return layer.feature.properties.FEATUREID.toString();
                    }, { opacity: 1.0 }
                    ).addTo(SELECTED_LAYER);

                newFeature.setStyle({
                    color: "black",
                    fillOpacity: 0.1,
                });
            }

            SELECTED_LAYER.addTo(MAP);

            LAYER_OPTIONS.addOverlay(SELECTED_LAYER, "Selected Catchments");
        }

        function catchRequest(comid){
            let coords = [0,0];

            let catchment_url_base =
            "https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/Catchments_NP21_Simplified/MapServer/0/query?where=FEATUREID%3D";
            let catchment_url_extension =
            "&text=&objectIds=&time=&timeRelation=esriTimeRelationOverlaps&geometry=&geometryType=esriGeometryEnvelope&inSR=&spatialRel=esriSpatialRelIntersects&distance=&units=esriSRUnit_Foot&relationParam=&outFields=*&returnGeometry=true&returnTrueCurves=false&maxAllowableOffset=&geometryPrecision=&outSR=&havingClause=&returnIdsOnly=false&returnCountOnly=false&orderByFields=&groupByFieldsForStatistics=&outStatistics=&returnZ=false&returnM=false&gdbVersion=&historicMoment=&returnDistinctValues=false&resultOffset=&resultRecordCount=&returnExtentOnly=false&sqlFormat=none&datumTransformation=&parameterValues=&rangeValues=&quantizationParameters=&featureEncoding=esriDefault&f=geojson";
            
            let catchment_query_url = catchment_url_base + comid + catchment_url_extension;

            $.ajax({
            async: false,
            type: "GET",
            url: catchment_query_url,
            success: function (data, textStatus, jqXHR) {
                //console.log(data);

                if (Object.entries(data)[1][1][0].geometry.type === "MultiPolygon") {
                    let firstEntries = Object.entries(data)[1][1][0].geometry.coordinates[0][0][0];
                    coords = firstEntries;
                } else {
                    let firstEntries = Object.entries(data)[1][1][0].geometry.coordinates[0][0];
                    coords = firstEntries;
                }

            },
            });

            return coords;
        }

        function comidClick(){
            //console.log("clicked");
            try {
                let comval = document.getElementById("comidBox").value;
                let comid = parseInt(comval);

                let coords = catchRequest(comid);
                
                //console.log(coords);
                //alert(coords);
                MAP.setView([coords[1], coords[0]], 12);
            }
            catch(err) {
                console.log(err);
                alert("COMID does not exist or was entered incorrectly")
            }
        }
        
        function coordsClick(){
            let lat = document.getElementById("latBox");
            let lon = document.getElementById("lonBox");
            MAP.setView([lat.value, lon.value], 12);
        }
        /*
        const DEFAULT_LAT = 49.5;
        const DEFAULT_LNG = -125.02;
        const DEFAULT_ZOOM = 13;

        // catchments
        const URL_NP21_CATCHMENTS =
            "https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/Catchments_NP21_Simplified/MapServer/0";
        // WBD - HUC_8
        const URL_NP21_HUC8 = "https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/WBD_NP21_Simplified/MapServer/2";
        // flowlines
        const URL_NP21_FLOWLINES =
            "https://watersgeo.epa.gov/arcgis/rest/services/NHDPlus_NP21/NHDSnapshot_NP21/MapServer/0";

        // build base map layer
        MAP = L.map("map").setView([DEFAULT_LAT, DEFAULT_LNG], DEFAULT_ZOOM);
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
        }).addTo(MAP);

        // build map layers
        const CATCHMENTS_LAYER = L.esri
            .featureLayer({
                url: URL_NP21_CATCHMENTS,
            })
            .addTo(MAP);
        CATCHMENTS_LAYER.setStyle({
            color: "orange",
            fillOpacity: 0,
        });

        const BOUNDARIES_LAYER = L.esri
            .featureLayer({
                url: URL_NP21_HUC8,
            })
            .addTo(MAP);
        BOUNDARIES_LAYER.setStyle({
            color: "purple",
            fillOpacity: 0,
        });

        const FLOWLINES_LAYER = L.esri
            .featureLayer({
                url: URL_NP21_FLOWLINES,
            })
            .addTo(MAP);

        const OVERLAY_MAPS = {
            "HUC8 Boundaries": BOUNDARIES_LAYER,
            Catchments: CATCHMENTS_LAYER,
            "Flow Lines": FLOWLINES_LAYER,
        };
        LAYER_OPTIONS = L.control.layers(null, OVERLAY_MAPS);
        LAYER_OPTIONS.addTo(MAP);

        //creates a legend for the map
        let LEGEND = L.control({ position: "bottomleft" });

        LEGEND.onAdd = function (MAP) {
            var div = L.DomUtil.create("div", "legend");
            div.setAttribute(
                "style",
                "background: rgba(255,255,255,0.8); box-shadow: 0 0 15px rgba(0,0,0,0.2); border-radius: 5px; float: left; text-align: center; padding: 6px 8px;"
            );
            div.innerHTML += "<h4>Legend</h4>";
            div.innerHTML += "<br>";
            div.innerHTML += '<i style="background: #000000"></i><span>Selected Catchments</span><br>';
            div.innerHTML += '<i style="background: #ffa500"></i><span>Catchments</span><br>';
            div.innerHTML += '<i style="background: #3388ff"></i><span>Flow Lines</span><br>';
            div.innerHTML += '<i style="background: #800080"></i><span>HUC8</span><br>';

            return div;
        };

        LEGEND.addTo(MAP);
        */
        /*Click Interactions, currently unused
             // app interaction
             function handleMapClick(e) {
                const LAT_LNG = e.latlng;
                sendMessageToDotnet(
                    `Message from map click lat: ${LAT_LNG.lat}, lng: ${LAT_LNG.lng}`
                );
            }
            MAP.on("click", handleMapClick);
        
            // dotnet <=> js message handlers
            // receive message dotnet
            window.chrome.webview.addEventListener("message", (event) => {
                console.log(`"message" event received from dotnet: `, event);
                const message = event.data;
                if (typeof message === "string")
                    this.document.getElementById("message-bar").innerHTML =
                        event.data;
            });
        
            // send message to dotnet
            function sendMessageToDotnet(message) {
                window.chrome.webview.postMessage(message);
            }
        */
    </script>
</body>
</html>